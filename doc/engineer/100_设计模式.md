# 设计模式

## 单例模式


### 介绍

什么是单例模式？
单例模式指在整个系统生命周期里，保证一个类只能产生一个实例，确保该类的唯一性。

单例模式分类
单例模式可以分为懒汉式和饿汉式，两者之间的区别在于创建实例的时间不同：

懒汉式：指系统运行中，实例并不存在，只有当需要使用该实例时，才会去创建并使用实例。（这种方式要考虑线程安全）
饿汉式：指系统一运行，就初始化创建实例，当需要时，直接调用即可。（本身就线程安全，没有多线程的问题）
单例类特点
构造函数和析构函数为private类型，目的禁止外部构造和析构
拷贝构造和赋值构造函数为private类型，目的是禁止外部拷贝和赋值，确保实例的唯一性
类里有个获取实例的静态函数，可以全局访问


### 实现


####  内部静态变量的懒汉单例（C++11 线程安全）

``` c++

///////////////////  内部静态变量的懒汉实现  //////////////////
class Single
{

public:
    // 获取单实例对象
    static Single &GetInstance();
	
	// 打印实例地址
    void Print();

private:
    // 禁止外部构造
    Single();

    // 禁止外部析构
    ~Single();

    // 禁止外部复制构造
    Single(const Single &signal);

    // 禁止外部赋值操作
    const Single &operator=(const Single &signal);
};

Single &Single::GetInstance()
{
    // 局部静态特性的方式实现单实例
    static Single signal;
    return signal;
}

void Single::Print()
{
	std::cout << "我的实例内存地址是:" << this << std::endl;
}

Single::Single()
{
    std::cout << "构造函数" << std::endl;
}

Single::~Single()
{
    std::cout << "析构函数" << std::endl;
}

```
-std=c++0x编译是使用了C++11的特性，在C++11内部静态变量的方式里是线程安全的，只创建了一次实例，内存地址是0x6016e8，这个方式非常推荐，实现的代码最少！



## 工厂模式 + 反射机制 ？

想要实现的功能：经常在项目中看到这种注册机制，到底是什么鬼？功能如下：

* 想要通过类名直接实例化一个对象，并把这对象注册，后面通过类名获取这个对象；方便形成执行链。
* 定义的一堆类自动注册对象创建者函数。。

``` c++

#include <string>
#include <map>

// 下面是个宏定义，通过类名来注册一个可以创建该类实例的创建函数；后续通过这个创建函数就可以创建该类的对象；

#define CF_REGISTER(className) \
    className* Create##className() \   //创建该类实列的函数
    { \
        return new className(); \
    } \
    RegisterAction g_createrRegister##className(#className, (PTRCreateObject)Create##className) 
        // 全局变量，类型是RegisterAction; 这个全局变量在对象的初始化中，调用一个单单例类，把类名 + 类创建函数 写入到注册map中。
        // 后续通过单例类 和  要创建的类名， 来获取类实例的创建函数

namespace Test {

typedef void* (*PTRCreateObject)(void);

class ClassFactory {
public:
    ~ClassFactory()
    {
    }
    void* GetClassByName(const std::string& name) 
            auto it = mapClassMap.find(name);
    		if (it == mapClassMap.end()) {
        		return nullptr;
    		}
    		return (it->second)();
    }
    void RegistClass(std::string name, PTRCreateObject method) 
            mapClassMap[name] = method;
    }
    static ClassFactory& GetInstance() {
            static ClassFactory singleClassFactory;
        	return singleClassFactory;
    }

private:
    ClassFactory()
    {
    }
    std::map<std::string, PTRCreateObject> mapClassMap;
};

class RegisterAction {
public:
    RegisterAction(std::string className, PTRCreateObject createFn)
    {
        ClassFactory::GetInstance().RegistClass(className, createFn);
    }
    ~RegisterAction()
    {
    }
};

} // namespace Test

```








### 参考：
1、[C++ 线程安全的单例模式总结](https://www.cnblogs.com/xiaolincoding/p/11437231.html)

## 参考：

[[图解九种常见的设计模式](https://segmentfault.com/a/1190000030850326)] : 这篇文章写的比较形象，可以参考

[C++ 常用设计模式](https://www.cnblogs.com/chengjundu/p/8473564.html) : 使用c++的实现的demo

[C++设计模式系列文章](https://zhuanlan.zhihu.com/p/94877789) : 这个是更全面的c++实现的demo，有github的代码仓

[设计模式目录](https://refactoringguru.cn/design-patterns/catalog) : 这是<<深入设计模式>>这本书的电子版本，写的感觉很不错











