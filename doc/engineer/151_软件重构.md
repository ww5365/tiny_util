# 软件重构


## DDD

https://mp.weixin.qq.com/s/HMLpjcE0UENUTfMK0Z9n8A


## 4.1 重构
所谓重构（refactoring） 是这样一个过程： 在不改变代码外在行为的前提下， 对代码做出修改， 以改进程序的内部结构。 
产品存量问题：
1：难以添加新特性。
2：存量代码难以理解。
3：难以保证产品的质量。
4：接口混乱。
5：简单堆砌式修改。
6：系统资源不足。
7：员工工作疲惫。
重构的好处：
1：改进软件设计。
2：使软件更容易被理解。
3：帮助你找到bugs。
4：助你提高编程效率。
Program SMaRT：performance高效，portable可移植，security安全，maintainable可维护，readable可读，reliability可靠，testable可测试。
重构等级要求：
L0：功能正确。功能点验收，自动化测试。
L1：无风险漏洞。门禁，静态检查，CodeDex，安全编码规范，CQI。
L2：代码整洁。通用编码规范，CodeStyle，CMetircs。
L3：架构敏捷。持续重构，架构可视化，SAI。
L4：持续演进。
重构场景对人的要求有不同：
1：小颗粒重构（函数级，小模块级），以开发人员为主，committer审核辅导。
2：大颗粒重构（架构级，大模块级），业务专家，软件专家。
重构时机：
1：事不过三。
2：添加功能时，让未来增加新特性时更加快速，更流畅。
3：修补错误时，因代码不够清晰而无法一目了然地发现错误。
4：复审代码时：经验传递，改善设计。
什么时候不适合做重构？
1：代码太混乱，设计完全错误，与其重构，还不如重新开始（重写）。
2：明天就是DeadLine，永远不要做“最后一分钟的修改”
3：重构工作量显著的影响估计，一个任务估计是3天，如果为了重构，需要更多时间(2天或更多)
4：没有任何更好的思路时不可重构。
两顶帽子：添加功能和重构，一次只做一件事。
1：添加新功能时，你不应该修改既有代码，只管添加新功能
2：重构时,你就不能再添加功能，只管改进程序结构
重构流程：
1：深入业务：挖掘问题，深入代码。
2：重构设计：领域建模，重构规划，兼容方案。
3：重构实施：工程基线，代码重构。
4：持续演进：模型演进，人员赋能。

## 4.2 代码坏味道
不同层次的代码坏味道：
1：直观：一眼过去就可以看到问题，比如魔鬼数字，函数/类过长，圈复杂度高，函数/变量命名不规范。
2：微观：需要仔细检查才能发现的问题，比如类字段定义不合理，函数功能不单一，变量作用域过长等问题。
3：宏观：代码架构上的整体问题，比如类的职责不单一，上帝类，分层不清楚，上下文混乱等问题。
简单设计四原则：
1：通过所有测试：软件系统对外部需求被正确地完成，包括功能性需求和非功能性需求，并通过了客户验收的标准。
2：尽可能消除重复：让软件走向高内聚，低耦合，达到良好正交性的过程，并不是所有的重复都可以消除， 这条原则被描述为最小化重复，而不是消除重复。
3：尽可能清晰表达：漂亮的代码如同优美的散文，从不隐藏设计者的意图，恰如其分的抽象，直截了当的控制，代码被阅读的次数远远大于其修改的次数。
4：更少的代码元素：尽可能的降低设计的复杂度，保持简单。
冗余和重复：
1：重复代码，在多个地点删刚看到同样的程序结构。
2：过多的注释，一段代码有着长长的注释，然后发现，这些注释之所以存在是因为代码很糟糕。
3：夸夸其谈的未来星，过度关注未来可能的变化，增加了不必要的东西。
局部膨胀：
1：过长参数列表，函数有太多的参数。
耦合结构不良：
1：发散式变化：某个模块（类、函数）经常因为不同的原因在不同的方向上发生变化。
2：霰弹式修改：每遇到某种变化， 都必须在许多不同的模块（类、函数）内做出许多小修改改。
3：switch惊悚现身：switch语句是根据类型码进行的多分支选择语句，写出短小的switch语句很难，即便是只有两种条件的switch语句也要比我们想要的单个代码块或函数大的多。写出只做一件事的switch语句也很难，switch天生要做N件事。
4：令人迷惑的临时字段，有时你会看到这样的对象：其内某个变量仅为某种特定场景而设，或者只在该对象某一段生命周期内生效。
代码坏味道工具：Xlint，Clang，FindBugs，CheckStyle，SourceMonitor，CodeDEX。
代码度量：代码规模，超大目录，文件行，文件重复，函数或者方法行，代码重复，圈复杂度，冗余代码，编译告警，静态告警，危险函数，编程规范。
4.3 重构手法
重构手法概述：
抽取方法 : extarct method
内联方法 : inline method
抽取类 : extract class
重命名 : rename
移动方法 : move

十六字真言：旧的不变，新的创建，一步切换，旧的再见。

简化语句：
1：合并条件表达式。
2：移动语句。
3：以卫语句取代嵌套条件表达式。
重组函数：
1：将查询函数和修改函数分离
2：已明确函数取代参数
3：提炼函数：提取功能，将部分代码提取到独立函数，方便复用和维护，提升可读性，提炼到一个独立的函数中， 并以这段代码的用途为这个函数命名，方便理解。
4：内联函数：消除多余的间接性，将函数和被调用的代码合并了，方便理解，重新组织函数的过程中，把多个函数代码内联到一个函数中，方便后续重构。
重组数据：
1：拆分变量：如果变量被多次赋值，且赋值的意义不同，意味着它们在函数中承担了多个职责，容易造成理解困难和修改出错，应该根据不同的职责被拆分成不同的变量，每个变量只承担一个职责。
2：提炼类：单一职责，将不同职责的代码提取到独立的类（模块）。重新组织类，将多个类合并到一起，以便按照其他方向进一步拆分。
3：内联类：消除多余的间接性，消除不在有独立职责的类。重新组织类，将多个类合并到一起，以便按照其他方向进一步拆分。

4：类继承体系重构手法系列
a：函数上移（反 函数下移）。字段上移（反 字段下移）。移除子类（反 以子类取代类型码）。
b：提炼超类，折叠继承体系，以委托取代超类，以委托取代子类。
系统级重构：
拆解后带来的收益：业务复杂度，需求变化频率，平均日活。
拆解中的成本：系统集成关系，数据迁移量，代码改动量。 


## 手法

拆 ： 单一职责  ：1个大源文件，实现多个类
合 ： 最小重复  : 不同switch分支中，使用多行实现，合成函数？
表 ： 开闭原则 ： 对修改关闭，对扩展开放   函数字段表，把swith用函数表实现
倒 ：  依赖倒置  ：  IOC

测试用例： 参数化， 参考第1组的   没有太明白。。



## 代码重构---卫语句取代嵌套条件表达式

``` c++

// 原始代码

if（it == 活的）{
    if（it == 人）{
        if（it ！= 女人）{
            return 不喜欢；
        } else {
            return 喜欢；
        }
    } else {
        return 不喜欢；
    }
} else {
    return 不喜欢；
}

//重构之后

if（it == 女人 && it == 活的） {return 喜欢}
return 不喜欢；

```


另外参考：https://www.cnblogs.com/Braveliu/p/7364369.html


## gtest

